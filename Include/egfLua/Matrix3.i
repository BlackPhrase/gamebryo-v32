// EMERGENT GAME TECHNOLOGIES PROPRIETARY INFORMATION
//
// This software is supplied under the terms of a license agreement or
// nondisclosure agreement with Emergent Game Technologies and may not
// be copied or disclosed except in accordance with the terms of that
// agreement.
//
//      Copyright (c) 1996-2009 Emergent Game Technologies.
//      All Rights Reserved.
//
// Emergent Game Technologies, Calabasas, CA 91302
// http://www.emergent.net

//
// SWIG Lua bindings for efd::Matrix3.
//
%module Matrix3;

%import <egfLua/MemObjectBindHelperLua.i>

// Only need one transform function
%ignore efd::Matrix3::operator*(const efd::Point3& pt) const;
%ignore efd::Matrix3::operator*(const Point4& pt) const;
%rename(Point3Transform) efd::Matrix3::operator*(const efd::Point3& pt, const efd::Matrix3& mat);


// SWIG cant distinguish between an array by pointer and a pointer to object.
// Ignore these for now. Reimplement below if necessary.
%ignore efd::Matrix3::TransformVertices;
%ignore efd::Matrix3::TransformNormals;
%ignore efd::Matrix3::TransformVerticesAndNormals;
%ignore efd::Matrix3::EigenSolveSymmetric;
%ignore efd::Matrix3::GetRow(efd::UInt32 index, efd::Float32* pRow) const;
%ignore efd::Matrix3::GetCol(efd::UInt32 index, efd::Float32* pCol) const;
%ignore efd::Matrix3::Snap;


%rename(ScalarMultiply) efd::Matrix3::operator *(efd::Float32) const;

// Use the macro defined in MemObjectBindHelperLua.i to add additional class overrides,
// methods, and typemaps. This also sets up certain header includes required when
// wrapping the class.
EE_SWIG_DEFINE_MEMOBJECT_SWIG_CLASS(efd, Matrix3)

//
//   Override the default versions of these functions generated by SWIG to ensure we use
//   the correct allocator. By default SWIG uses the standard allocator. We want SWIG to
//   use the Emergent allocator when creating instances of this type.
//
namespace efd
{
%exception Matrix3::Matrix3(const efd::Point3&, const efd::Point3&, const efd::Point3&)
{
   // Note - Lua (and Toolbench) uses row-major, our C++ class expects column-major.
   efd::Point3 c1(arg1->x, arg2->x, arg3->x);
   efd::Point3 c2(arg1->y, arg2->y, arg3->y);
   efd::Point3 c3(arg1->z, arg2->z, arg3->z);
   
   result = EE_NEW efd::Matrix3(c1, c2, c3);   
}

// Normally the default Matrix3 constructor leaves members uninitialized for performace reasons
// but when bound to swig we need the members initialized before they get used and we don't have
// as much control over this as C++ code typically does, so we replace the default constructor
// with one that initializes the parameters.
%exception Matrix3::Matrix3()
{
   result = EE_NEW efd::Matrix3();
   result->MakeZero();
}

} // namespace efd



// Add a __str__ function used in Lua when tostring is called on our object.
// Print out the value in row-major order.
EE_SWIG_ADD_STR_FUNCTION(
    efd,
    Matrix3,
    "Matrix3({%.6f, %.6f, %.6f}, {%.6f, %.6f, %.6f}, {%.6f, %.6f, %.6f})",
        $self->GetEntry(0, 0), $self->GetEntry(0, 1), $self->GetEntry(0, 2),
        $self->GetEntry(1, 0), $self->GetEntry(1, 1), $self->GetEntry(1, 2),
        $self->GetEntry(2, 0), $self->GetEntry(2, 1), $self->GetEntry(2, 2));

%include <typemaps.i>

// Allow us to pass in Lua tables for functions that take arrays of Float32 values.
%apply (efd::Float32 INPUT[ANY], efd::Float32 INPUT[ANY], efd::Float32 INPUT[ANY]) {(efd::Float32 a[3], efd::Float32 b[3], efd::Float32 c[3])};
%apply (efd::UInt32, efd::Float32 INPUT[ANY]) {(efd::UInt32 index, const efd::Float32* pRow)}
%apply (efd::UInt32, efd::Float32 INPUT[ANY]) {(efd::UInt32 index, const efd::Float32* pCol)}


// Add support for operator[]
namespace efd
{

%extend Matrix3
{
    // Construct a new matrix from 3 tables, each containing 3 float values (row-major order) 
    Matrix3(efd::Float32 a[3], efd::Float32 b[3], efd::Float32 c[3])
    {
        efd::Point3 c1(a[0], b[0], c[0]);
        efd::Point3 c2(a[1], b[1], c[1]);
        efd::Point3 c3(a[2], b[2], c[2]);

        return EE_NEW efd::Matrix3(c1, c2, c3);
    }

    //
    // SWIG cannot automatically generated operator[] but we can do it manually
    // by implementing __getitem__ and __setitem__
    //
    const efd::Point3& __getitem__(efd::SInt32 index) const
    {
        // Verify the index is valid.
        if (abs(index) > 3)
        {
            // If you hit this assert you attempted to index an object from Lua past the end
            // of the object's array bounds.
            EE_ASSERT(abs(index) > 3);
            return efd::Point3::ZERO;
        }

        // If index is negative, start from the back.
        if (index < 0) index = 3 - index + 1;

        // substract 1 from index to conform to Lua standards where indexes start at 1.
        static efd::Point3 row;
        $self->GetRow(index-1, row);

        return row;
    }
    void __setitem__(efd::SInt32 index, const efd::Point3& val)
    {
        // Verify the index is valid.
        if (abs(index) > 3)
        {
            // If you hit this assert you attempted to index an object from Lua past the end
            // of the object's array bounds.
            EE_ASSERT(abs(index) > 3);
            return;
        }

        // If index is negative, start from the back.
        if (index < 0) index = 3 - index + 1;

        // substract 1 from index to conform to Lua standards where indexes start at 1.
        $self->SetRow(index-1, val);
    }
}
} // namespace


%{
#include <efd/Matrix3.h>
%}

%import "egfLua/Point3.i"
%include "efd/Matrix3.h"
